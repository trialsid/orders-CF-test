\documentclass[11pt, a4paper]{report}

% =============================================================================
% PACKAGES
% =============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{microtype}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}
\usepackage{pifont}
\usepackage{amssymb}
\usepackage{graphicx}

% =============================================================================
% CONFIGURATION
% =============================================================================

% Page Geometry
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Brand Colors
\definecolor{emerald}{RGB}{16, 185, 129} 
\definecolor{midnight}{RGB}{15, 23, 42}
\definecolor{slate}{RGB}{100, 116, 139}
\definecolor{paper}{RGB}{248, 250, 252}
\definecolor{alert}{RGB}{220, 38, 38}
\definecolor{gold}{RGB}{217, 119, 6}
\definecolor{info}{RGB}{37, 99, 235}
\definecolor{purple}{RGB}{124, 58, 237}

% Hyperlink Setup
\hypersetup{
    colorlinks=true,
    linkcolor=emerald,
    filecolor=magenta,      
    urlcolor=info,
    pdftitle={Order Ieeja: The Codebase Chronicles},
}

% Header/Footer Setup
\pagestyle{fancy}
\fancyhf{}
\lhead{\small \textbf{Order Ieeja}}
\rhead{\small \textit{Deep Code Analysis}}
\cfoot{\thepage}

% =============================================================================
% CUSTOM BOX MACROS
% =============================================================================

% 1. The Good (Excellence)
\newtcolorbox{goodbox}[1]{
    colback=emerald!5!white,
    colframe=emerald,
    title=\textbf{\ding{51} The Good: #1},
    fonttitle=\bfseries,
    boxrule=0.5mm,
    arc=2mm,
    left=2mm, right=2mm, top=2mm, bottom=2mm
}

% 2. The Bad (Critique)
\newtcolorbox{badbox}[1]{
    colback=gold!5!white,
    colframe=gold,
    title=\textbf{\ding{45} The Bad: #1},
    fonttitle=\bfseries,
    boxrule=0.5mm,
    arc=2mm,
    left=2mm, right=2mm, top=2mm, bottom=2mm
}

% 3. The Ugly (Danger)
\newtcolorbox{uglybox}[1]{
    colback=alert!5!white,
    colframe=alert,
    title=\textbf{\ding{55} The Ugly: #1},
    fonttitle=\bfseries,
    boxrule=0.5mm,
    arc=2mm,
    left=2mm, right=2mm, top=2mm, bottom=2mm
}

% 4. Code Insight (Neutral)
\newtcolorbox{codebox}[1]{
    colback=slate!5!white,
    colframe=slate,
    title=\textbf{\ding{118} Code Insight: #1},
    fonttitle=\bfseries,
    boxrule=0.5mm,
    arc=2mm,
    left=2mm, right=2mm, top=2mm, bottom=2mm
}

% Code Listing Styling
\lstset{
    backgroundcolor=\color{paper},
    basicstyle=\ttfamily\small\color{midnight},
    breaklines=true,
    keywordstyle=\color{purple}\bfseries,
    commentstyle=\color{slate}\itshape,
    stringstyle=\color{emerald},
    frame=l,
    framesep=10pt,
    rulecolor=\color{slate},
    captionpos=b,
    escapechar=|,
    numbers=left,
    numberstyle=\tiny\color{slate}
}

% =============================================================================
% TITLE PAGE
% =============================================================================
\title{
    \vspace{2cm}
    \textbf{\Huge Order Ieeja} \\
    \vspace{0.5cm}
    \Large The Codebase Chronicles \\
    \vspace{1cm}
    \large The Good, The Bad, and The Ugly \\
    \vspace{2cm}
    \textit{A Brutally Honest Architectural Review}
}
\author{System Architects}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

% =============================================================================
% CHAPTER 1
% =============================================================================
\chapter{The Foundation: Auth & Security}
\textit{File: \texttt{functions/\_auth.js}}

\section{The Manual JWT Implementation}
Instead of using a library like `jsonwebtoken` or `jose`, the project manually implements JWT signing and verification using the Web Crypto API (`crypto.subtle`).

\begin{goodbox}{Zero Dependencies}
By using `crypto.subtle` directly, the project avoids the heavy weight of external Node.js polyfills. This keeps the Worker bundle size microscopic and startup times instant.
\end{goodbox}

\begin{badbox}{Reinventing the Wheel}
The `signToken` and `verifyToken` functions manually construct the JWT string (`header.payload.signature`).
\textbf{Risk:} If the JWT spec changes or if there's a subtle encoding edge case (like unescaped characters in Base64Url), this custom implementation might break or introduce security vulnerabilities that a battle-tested library would handle.
\end{badbox}

\section{Password Hashing (PBKDF2)}
\textit{Lines 225-248 in \texttt{\_auth.js}}

\begin{codebox}{Implementation Details}
\begin{lstlisting}[language=JavaScript]
const PBKDF2_ITERATIONS = 100000;
// ...
const keyMaterial = await crypto.subtle.importKey(...)
const derivedBits = await crypto.subtle.deriveBits(...)
\end{lstlisting}
\end{codebox}

\begin{uglybox}{Algorithm Choice}
**PBKDF2 is outdated.**
While 100,000 iterations is the NIST recommendation, PBKDF2 is vulnerable to GPU acceleration. A modern GPU can try millions of passwords per second.
\textbf{Why it's here:} Cloudflare Workers' `crypto.subtle` implementation has historically lacked support for **Argon2id** or **scrypt**, forcing developers to use PBKDF2. It is a "forced error" due to platform constraints.
\end{uglybox}

\section{Token Versioning}
\textit{Lines 769-800 in \texttt{\_auth.js}}

The `requireAuth` function checks `user.token_version` against the DB.

\begin{goodbox}{Instant Revocation}
This is a stellar pattern. Most stateless JWT systems cannot ban a user until the token expires. Here, changing `token_version` in the DB instantly invalidates all active tokens.
\end{goodbox}

% =============================================================================
% CHAPTER 2
% =============================================================================
\chapter{The Engine: Order Processing}
\textit{File: \texttt{functions/order.js}}

\section{Atomicity & The Batch}
\textit{Lines 346-357 in \texttt{order.js}}

\begin{codebox}{The Transaction}
\begin{lstlisting}[language=JavaScript]
await db.batch([
  ...addressStatements,
  orderStatement,
  ...orderItemsStatements,
  ...stockStatements
]);
\end{lstlisting}
\end{codebox}

\begin{goodbox}{D1 Batching}
Using `db.batch()` ensures that we don't end up with an Order that has no Items, or Stock deducted for an Order that failed to save. It effectively gives us SQL Transactions over HTTP.
\end{goodbox}

\begin{uglybox}{Reactive Stock Checking}
The stock check happens in the application layer first (`validateOrder`), then again in the DB via `CHECK (stock_quantity >= 0)`.
\textbf{The Ugly Truth:} Between the time `validateOrder` reads the stock and `db.batch` writes the decrement, another request could steal the last item. The `db.batch` will fail, but the user gets a generic 500 error. There is no "reservation" system. In a flash sale, this is a UX nightmare.
\end{uglybox}

\section{Validation Logic}
\textit{File: \texttt{shared/order-schema.js}}

\begin{badbox}{Manual Mapping}
The function `formFromOrderRequest` manually maps fields:
\texttt{name: customer.name, phone: customer.phone...}
\textbf{The Bad:} This is brittle. If we add a new field like `email`, we have to update:
1. The DB Schema
2. The Frontend Form
3. The `formFromOrderRequest` mapper
4. The `validateOrderRequest` validator
It violates the Open/Closed principle. A schema validation library (like Zod) would automate this mapping.
\end{badbox}

% =============================================================================
% CHAPTER 3
% =============================================================================
\chapter{The Frontend: State & Context}
\textit{File: \texttt{src/context/AuthContext.tsx}}

\section{Session Refresh Logic}
\textit{Lines 53-89 in \texttt{AuthContext.tsx}}

\begin{codebox}{Race Condition Handling}
\begin{lstlisting}[language=JavaScript]
const refreshPromiseRef = useRef<Promise<string | null> | null>(null);
// ...
if (refreshPromiseRef.current) {
  return refreshPromiseRef.current;
}
\end{lstlisting}
\end{codebox}

\begin{goodbox}{Promise Deduping}
This is excellent. If the app makes 5 API calls simultaneously and all return 401, the `useApiClient` hook will trigger `refreshSession` 5 times. This Ref ensures we only hit the `/auth/refresh` endpoint ONCE, and all 5 calls wait for that single promise. It prevents a "thundering herd" on the auth server.
\end{goodbox}

\section{API Client Wrapper}
\textit{File: \texttt{src/hooks/useApiClient.ts}}

\begin{uglybox}{Implicit Logout}
\begin{lstlisting}[language=JavaScript]
if (response.status === 401) {
  logout();
}
\end{lstlisting}
The `useApiClient` hook automatically logs the user out if the refresh fails.
\textbf{The Ugly:} This can be jarring. If the internet flickers or the server returns a 500 that looks like a 401, the user is booted to the login screen and loses their cart/checkout state. A "soft" failure (showing a "Session Expired" modal) is better than a hard redirect.
\end{uglybox}

% =============================================================================
% CHAPTER 4
% =============================================================================
\chapter{The Infrastructure: D1 & KV}

\section{Database Schema}
\textit{File: \texttt{deep-reports/05\_data\_model\_d1.txt}}

\begin{badbox}{Strict Foreign Keys vs. Restoration}
SQLite in D1 enforces Foreign Keys strictly.
\textbf{The Bad:} You cannot insert an Order before its User exists. This makes "naive" backups (dumping tables alphabetically) impossible to restore. The project requires a custom script `scripts/reorder-d1-export.js` just to make backups usable. This is a fragile operational dependency.
\end{badbox}

\section{Rate Limiting}
\textit{File: \texttt{functions/\_auth.js}}

\begin{uglybox}{Fail-Open Design}
\begin{lstlisting}[language=JavaScript]
if (!store) {
  console.warn("LOGIN_RATE_LIMIT_KV binding missing...");
  return null; // Proceed without limiting
}
\end{lstlisting}
If the KV binding is missing (e.g., misconfiguration), the rate limiter silently disables itself.
\textbf{The Ugly:} A security feature should ideally "Fail Closed" (deny access) or scream louder. Here, an attacker could brute-force the login API if the developer forgets to bind the KV namespace, and they might never know.
\end{uglybox}

% =============================================================================
% CHAPTER 5
% =============================================================================
\chapter{Conclusion: The Verdict}

\section{Architectural Scorecard}

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{8cm}@{}}
\toprule
\textbf{Category} & \textbf{Grade} & \textbf{Notes} \\ \midrule
\textbf{Security} & B+ & Strong token handling, but weak password hashing (PBKDF2) and manual JWT implementation. \\
\textbf{Performance} & A & Excellent use of ETags, D1 batching, and zero-dependency functions. \\
\textbf{Maintainability} & B- & Manual schema mapping and lack of automated tests hurt long-term stability. \\
\textbf{Reliability} & C+ & No transaction rollback logic (beyond D1 batch), fail-open rate limits, and fragile backup restoration. \\ \bottomrule
\end{tabular}
\end{table}

\section{Final Thoughts}
Order Ieeja is a **high-performance race car with no seatbelts**.
It is built for speed and low cost (Cloudflare Free Tier optimization). The engineering is cleverâ€”sometimes \textit{too} clever (manual JWTs, custom Promise deduping).

To graduate from a "Project" to a "Product", it needs:
1. **Automated Tests:** The lack of tests is the single biggest risk.
2. **Zod/Schema Validation:** Replace manual mapping with a robust library.
3. **Observability:** Add centralized logging to catch the "Fail-Open" cases.

\end{document}
